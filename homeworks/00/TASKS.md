## Двоични числа

### `Bit`

Представяне на битове в Хаскел.

"Същото" като булеви стойности, но ще ги използваме за данни и двоични числа,
а не за control flow.

### `Binary`

Рекурсивна дефиниция на двоични числа.

С `End` ще означим край на двоичното ни число,
докато с конструктора (който е и оператор)
```haskell
(:.) :: Binary -> Bit -> Binary
```
можем да "разширяваме" отдясно двоично число.

Обърнете внимание на декларацията
```haskell
infixl 6 :.
```
Тя казва на Хаскел компилатора, че `(:.)` ще е **лявоасоциативен** оператор, т.е.
```haskell
End :. One :. Zero :. One
```
всъщност означава
```haskell
((End :. One) :. Zero) :. One
```
, а не
```haskell
End :. (One :. (Zero :. One))
```
, което е невалидна стойност, защото например в `Zero :. One` конструкторът би бил приложен над
два `Bit`-а, докато той взима за ляв/първи аргумент `Binary` стойност.

Това е важно също и когато pattern match-вате върху `(:.)` - получавате бит отдясно и остатъчното двоично число отляво.

Декларацията специфицира и приоритета на конструктора, но това вероятно не е съществено за домашното.



##### Примери за двоични числа представени чрез `Binary`

|Десетично|Двоично|`Binary`|
|-----|-----|-----|
|0|0|`End`|
|6|110|`End :. One :. One :. Zero`|
|5|101|`End :. One :. Zero :. One`|
|8|1000|`End :. One :. Zero :. Zero :. Zero`|
|42|101010|`End :. One :. Zero :. One :. Zero :. One :. Zero`|
|42|101010|`End :. Zero :. Zero :. Zero :. Zero :. Zero :. One :. Zero :. One :. Zero :. One :. Zero`|
|511|111111111|`End :. One :. One :. One :. One :. One :. One :. One :. One :. One`|

Обърнете внимание как всяко число има безкрайно много представяния - винаги можем да лепим водещи нули.

Например, в таблицата има две различни представяния на 42.

### Дефиниция - Канонично `Binary`
Канонично `Binary`, ще наричаме такова, което **няма** водещи нули, т.е. не изпълнява `hasLeadingZero` (вижте съответната задача).

### Бележка за тестовете

Има някои тестове, които са базирани на свойства, които дадени функции имат съвместно с други.

Например има тест за свойството "за всяко двоично число bin `binaryToInteger (succBinary bin) == 1 + binaryToInteger bin`".

Поради това е възможно не всички тестове да минават преди да са имплементирани всички функции (в този случай най-важните за тези тестове са `binaryToInteger` и `integerToBinary`).

Те са отделени в своя секция, която се казва `properties`.

## Задачи

### 2т. `succBinary :: Binary -> Binary`

Увеличете подаденото двоично число с 1.

##### Примери

```
> succBinary End
End :. One
> succBinary (End :. Zero)
End :. One
> succBinary (End :. One :. One :. One)
End :. One :. Zero :. Zero :. Zero
```

### 1т. `integerToBinary :: Integer -> Binary`

Конвертирайте даденото цяло число към двоично представяне.

Може да допуснете, че числото е неотрицателно.

Генерирайте канонични числа.

##### Примери

```haskell
> integerToBinary 0
End
> integerToBinary 69
End :. One :. Zero :. Zero :. Zero :. One :. Zero :. One
> integerToBinary 5
End :. One :. Zero :. One
> integerToBinary 7
End :. One :. One :. One
```

### 1т. `binaryToInteger :: Binary -> Integer`

Конвертирайте даденото двоично число към цяло.

##### Примери

```haskell
> binaryToInteger End
0
> binaryToInteger (End :. One :. Zero :. Zero :. Zero :. One :. Zero :. One)
69
> binaryToInteger (End :. One :. Zero :. Zero :. Zero :. Zero)
16
> binaryToInteger (End :. Zero :. One)
1
```

## Не е позволено да използвате `binaryToInteger` и `integerToBinary` по-надолу

### 1т. `hasLeadingZero :: Binary -> Bool`

Проверете дали даденото число има водеща нула.

##### Примери

```haskell
> hasLeadingZero End
False
> hasLeadingZero $ End :. One
False
> hasLeadingZero $ End :. Zero
True
> hasLeadingZero $ End :. Zero :. One :. Zero
True
```

### 0т. `isEnd :: Binary -> Bool`

Направете функция която засича дали двоичното число е `End`.

Полезно за следващата задача.

### 3т. `canonicalise :: Binary -> Binary`

Конвертирайте даденото двоично число към канонично такова.

##### Примери

```haskell
> canonicalise End
End
> canonicalise (End :. One)
End :. One
> canonicalise (End :. Zero)
End
> canonicalise (End :. Zero :. One :. Zero)
End :. One :. Zero
```

### 2т. `addBinary :: Binary -> Binary -> Binary`

Имплементирайте събиране за двоични числа.

##### Примери

```haskell
> addBinary End (End :. One)
End :. One
> addBinary (End :. Zero) (End :. One)
End :. One
> addBinary (End :. One) (End :. Zero)
End :. One
> addBinary (End :. One :. Zero) (End :. One :. Zero :. Zero)
End :. One :. One :. Zero
```

### Бонус - `Can`

Както забелязахте, горното представяне на двоични числа има недостатъка,
че позволява всяко число да бъде представено по безкраен брой начини - слагайки
колкото искаме нули "отпред" на числото.

Би било хубаво да имаме тип данни, който вместо това позволява на всяко число
да има **само едно** представяне.

Това има доста ползи, например че проверката за равенство вече е директна "синтактична" проверка. С други думи, ще е достатъчно да видим дали конструкторите и битовете на две числа съвпадат, за разлика от при `Binary`, където трябва да се съобразим с водещи нули. Като цяло по този начин, при всички операции над числа, няма да трябва да мислим за водещи нули.

Този стил на изразяване на данните е прието да се нарича "правилно по построение" (correct by construction), защото типът който имаме допуска да се конструират само стойности, изпълняващи някакво свойство което искаме (в този случай то е "каноничност").

Вашата задача е да измислите два типа, както и няколко функции над тях.

### 3т. `LeadingOne`

Напишете тим данни, който изразява "двоични числа които имат водеща единица".

Напомням, че конструкторите нямат някакъв специален "смисъл" в тях - те са само индикатори
за човекът който ги чете, какво "трябва да си мисли".

### 1т. `canOne`

Щом всички числа от `LeadingOne` имат водеща единица, значи със сигурност
имат само едно представяне, защото няма как да добавяме колкото си искаме нули отпред.

Дайте за стойност на `canOne` единственото представяне на `1`.

### 1т. `Can`

Използвайки миналия тип ще е възможно да изразим вече "число което е канонично по конструкция". То или е `0`, или със сигурност има водеща единица.

### 0т. `canZero`

Нулата трябва да има единство представяне от тип `Can` - дайте го за стойност на `canZero`.

### 1т. `snoc`

Залепете подаденият `Bit` "най-отзад" на подаденото канонично двоично число.

Може да е полезно за някоя друга задача по-нататък.

##### Примери с псевдокод
```
> snoc 110 1
1101
// тъй като имаме канонично представяне, не би трябвало да има как да получим 00
> snoc 0 0
0
```

### 1т. `forgetLeadingOne`

Имплементирайте функция която да "забравя" че задължително има водеща единица
подаденото число, като го конвертира към `Binary` (което няма такава гаранция).

### 1т. `forget`

Имплементирайте функция която да "забравя" че подаденото число е канонично, като го конвертира към `Binary` (което няма такава гаранция).

Не слагайте излишни водещи нули на резултата, когато извършвате тази операция.

### 2т. `canonicalise`

Имплементирайте канонизиране на двоични числа отново, но този път запазвайки "доказателство" (под формата на типа `Can`), че резултатът в действителност е канонично число.
